/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @caffeinelabs/bindgen@0.1.0.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Actor, HttpAgent, type HttpAgentOptions, type ActorConfig, type Agent, type ActorSubclass } from "@icp-sdk/core/agent";
import type { Principal } from "@icp-sdk/core/principal";
import { idlFactory, type _SERVICE } from "./declarations/backend.did";
export interface Some<T> {
    __kind__: "Some";
    value: T;
}
export interface None {
    __kind__: "None";
}
export type Option<T> = Some<T> | None;
function some<T>(value: T): Some<T> {
    return {
        __kind__: "Some",
        value: value
    };
}
function none(): None {
    return {
        __kind__: "None"
    };
}
function isNone<T>(option: Option<T>): option is None {
    return option.__kind__ === "None";
}
function isSome<T>(option: Option<T>): option is Some<T> {
    return option.__kind__ === "Some";
}
function unwrap<T>(option: Option<T>): T {
    if (isNone(option)) {
        throw new Error("unwrap: none");
    }
    return option.value;
}
function candid_some<T>(value: T): [T] {
    return [
        value
    ];
}
function candid_none<T>(): [] {
    return [];
}
function record_opt_to_undefined<T>(arg: T | null): T | undefined {
    return arg == null ? undefined : arg;
}
export class ExternalBlob {
    _blob?: Uint8Array<ArrayBuffer> | null;
    directURL: string;
    onProgress?: (percentage: number) => void = undefined;
    private constructor(directURL: string, blob: Uint8Array<ArrayBuffer> | null){
        if (blob) {
            this._blob = blob;
        }
        this.directURL = directURL;
    }
    static fromURL(url: string): ExternalBlob {
        return new ExternalBlob(url, null);
    }
    static fromBytes(blob: Uint8Array<ArrayBuffer>): ExternalBlob {
        const url = URL.createObjectURL(new Blob([
            new Uint8Array(blob)
        ], {
            type: 'application/octet-stream'
        }));
        return new ExternalBlob(url, blob);
    }
    public async getBytes(): Promise<Uint8Array<ArrayBuffer>> {
        if (this._blob) {
            return this._blob;
        }
        const response = await fetch(this.directURL);
        const blob = await response.blob();
        this._blob = new Uint8Array(await blob.arrayBuffer());
        return this._blob;
    }
    public getDirectURL(): string {
        return this.directURL;
    }
    public withUploadProgress(onProgress: (percentage: number) => void): ExternalBlob {
        this.onProgress = onProgress;
        return this;
    }
}
export interface Budget {
    id: BudgetId;
    month: bigint;
    carryOver: number;
    categoryLimits: Array<BudgetCategoryLimit>;
}
export interface Account {
    id: AccountId;
    balance: number;
    name: string;
}
export type BudgetId = bigint;
export interface BudgetCategoryLimit {
    categoryId: CategoryId;
    limitAmount: number;
}
export type BankConnectionId = bigint;
export interface Report {
    id: bigint;
    filters?: string;
    endDate: bigint;
    name: string;
    createdAt: bigint;
    reportType: ReportType;
    updatedAt: bigint;
    startDate: bigint;
}
export interface Transaction {
    id: TransactionId;
    categoryId: CategoryId;
    accountId: AccountId;
    date: bigint;
    tags: Array<TagId>;
    amount: number;
}
export type BankConnectionStatus = {
    __kind__: "syncError";
    syncError: {
        error: string;
        timestamp: bigint;
    };
} | {
    __kind__: "idle";
    idle: null;
} | {
    __kind__: "lastSynced";
    lastSynced: {
        timestamp: bigint;
    };
} | {
    __kind__: "inProgress";
    inProgress: null;
};
export type TagId = bigint;
export type TransactionId = bigint;
export interface Tag {
    id: TagId;
    name: string;
}
export interface BudgetSummary {
    month: bigint;
    totalIncomeBudget: number;
    actualIncome: number;
    actualExpenses: number;
    remainingIncomeBudget: number;
    totalExpenseBudget: number;
    remainingExpenseBudget: number;
}
export interface CsvTransactionRow {
    categoryId: CategoryId;
    accountId: AccountId;
    date: bigint;
    tagIds: Array<TagId>;
    amount: number;
}
export interface BankConnection {
    id: BankConnectionId;
    status: BankConnectionStatus;
    name: string;
    connectionType: string;
    nextSyncTimestamp?: bigint;
    createdTimestamp: bigint;
    lastSync?: bigint;
    retryAttempts: bigint;
}
export type AccountId = bigint;
export type CategoryId = bigint;
export interface Category {
    id: CategoryId;
    isExpense: boolean;
    name: string;
}
export interface UserProfile {
    name: string;
}
export enum ReportType {
    categoryBreakdown = "categoryBreakdown",
    incomeVsExpenses = "incomeVsExpenses"
}
export enum UserRole {
    admin = "admin",
    user = "user",
    guest = "guest"
}
export interface backendInterface {
    _initializeAccessControlWithSecret(userSecret: string): Promise<void>;
    assignCallerUserRole(user: Principal, role: UserRole): Promise<void>;
    createAccount(name: string): Promise<AccountId>;
    createBankConnection(name: string, connectionType: string): Promise<BankConnectionId>;
    createBudget(month: bigint, categoryLimits: Array<BudgetCategoryLimit>, carryOver: number): Promise<BudgetId>;
    createCategory(name: string, isExpense: boolean): Promise<CategoryId>;
    createReport(reportType: ReportType, startDate: bigint, endDate: bigint, filters: string | null): Promise<bigint>;
    createTag(name: string): Promise<TagId>;
    createTransaction(accountId: AccountId, categoryId: CategoryId, amount: number, date: bigint, tagIds: Array<TagId>): Promise<TransactionId>;
    createTransactionsFromCsvRows(csvTransactions: Array<CsvTransactionRow>): Promise<Array<TransactionId>>;
    deleteBankConnection(bankConnectionId: BankConnectionId): Promise<void>;
    deleteBudget(budgetId: BudgetId): Promise<void>;
    deleteReport(reportId: bigint): Promise<void>;
    deleteTag(tagId: TagId): Promise<void>;
    getAccounts(): Promise<Array<Account>>;
    getBankConnection(bankConnectionId: BankConnectionId): Promise<BankConnection | null>;
    getBankConnections(): Promise<Array<BankConnection>>;
    getBudget(budgetId: BudgetId): Promise<Budget | null>;
    getBudgetSummary(month: bigint): Promise<BudgetSummary>;
    getBudgets(): Promise<Array<Budget>>;
    getCallerUserProfile(): Promise<UserProfile | null>;
    getCallerUserRole(): Promise<UserRole>;
    getCategories(): Promise<Array<Category>>;
    getReport(reportId: bigint): Promise<Report | null>;
    getReports(): Promise<Array<Report>>;
    getTags(): Promise<Array<Tag>>;
    getTransactions(): Promise<Array<Transaction>>;
    getTransactionsByDateRange(startDate: bigint, endDate: bigint): Promise<Array<Transaction>>;
    getUserProfile(user: Principal): Promise<UserProfile | null>;
    isCallerAdmin(): Promise<boolean>;
    listReports(): Promise<Array<Report>>;
    saveCallerUserProfile(profile: UserProfile): Promise<void>;
    syncBankConnection(bankConnectionId: BankConnectionId): Promise<void>;
    updateBankConnectionSyncStatus(bankConnectionId: BankConnectionId, newStatus: BankConnectionStatus): Promise<void>;
    updateBudget(budgetId: BudgetId, month: bigint, categoryLimits: Array<BudgetCategoryLimit>, carryOver: number): Promise<void>;
    updateReport(reportId: bigint, reportType: ReportType, startDate: bigint, endDate: bigint, filters: string | null): Promise<void>;
}
import type { BankConnection as _BankConnection, BankConnectionId as _BankConnectionId, BankConnectionStatus as _BankConnectionStatus, Budget as _Budget, Report as _Report, ReportType as _ReportType, UserProfile as _UserProfile, UserRole as _UserRole } from "./declarations/backend.did.d.ts";
export class Backend implements backendInterface {
    constructor(private actor: ActorSubclass<_SERVICE>, private _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, private _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, private processError?: (error: unknown) => never){}
    async _initializeAccessControlWithSecret(arg0: string): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor._initializeAccessControlWithSecret(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor._initializeAccessControlWithSecret(arg0);
            return result;
        }
    }
    async assignCallerUserRole(arg0: Principal, arg1: UserRole): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n1(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.assignCallerUserRole(arg0, to_candid_UserRole_n1(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
    async createAccount(arg0: string): Promise<AccountId> {
        if (this.processError) {
            try {
                const result = await this.actor.createAccount(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createAccount(arg0);
            return result;
        }
    }
    async createBankConnection(arg0: string, arg1: string): Promise<BankConnectionId> {
        if (this.processError) {
            try {
                const result = await this.actor.createBankConnection(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createBankConnection(arg0, arg1);
            return result;
        }
    }
    async createBudget(arg0: bigint, arg1: Array<BudgetCategoryLimit>, arg2: number): Promise<BudgetId> {
        if (this.processError) {
            try {
                const result = await this.actor.createBudget(arg0, arg1, arg2);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createBudget(arg0, arg1, arg2);
            return result;
        }
    }
    async createCategory(arg0: string, arg1: boolean): Promise<CategoryId> {
        if (this.processError) {
            try {
                const result = await this.actor.createCategory(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createCategory(arg0, arg1);
            return result;
        }
    }
    async createReport(arg0: ReportType, arg1: bigint, arg2: bigint, arg3: string | null): Promise<bigint> {
        if (this.processError) {
            try {
                const result = await this.actor.createReport(to_candid_ReportType_n3(this._uploadFile, this._downloadFile, arg0), arg1, arg2, to_candid_opt_n5(this._uploadFile, this._downloadFile, arg3));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createReport(to_candid_ReportType_n3(this._uploadFile, this._downloadFile, arg0), arg1, arg2, to_candid_opt_n5(this._uploadFile, this._downloadFile, arg3));
            return result;
        }
    }
    async createTag(arg0: string): Promise<TagId> {
        if (this.processError) {
            try {
                const result = await this.actor.createTag(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createTag(arg0);
            return result;
        }
    }
    async createTransaction(arg0: AccountId, arg1: CategoryId, arg2: number, arg3: bigint, arg4: Array<TagId>): Promise<TransactionId> {
        if (this.processError) {
            try {
                const result = await this.actor.createTransaction(arg0, arg1, arg2, arg3, arg4);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createTransaction(arg0, arg1, arg2, arg3, arg4);
            return result;
        }
    }
    async createTransactionsFromCsvRows(arg0: Array<CsvTransactionRow>): Promise<Array<TransactionId>> {
        if (this.processError) {
            try {
                const result = await this.actor.createTransactionsFromCsvRows(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.createTransactionsFromCsvRows(arg0);
            return result;
        }
    }
    async deleteBankConnection(arg0: BankConnectionId): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteBankConnection(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteBankConnection(arg0);
            return result;
        }
    }
    async deleteBudget(arg0: BudgetId): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteBudget(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteBudget(arg0);
            return result;
        }
    }
    async deleteReport(arg0: bigint): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteReport(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteReport(arg0);
            return result;
        }
    }
    async deleteTag(arg0: TagId): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.deleteTag(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.deleteTag(arg0);
            return result;
        }
    }
    async getAccounts(): Promise<Array<Account>> {
        if (this.processError) {
            try {
                const result = await this.actor.getAccounts();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getAccounts();
            return result;
        }
    }
    async getBankConnection(arg0: BankConnectionId): Promise<BankConnection | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getBankConnection(arg0);
                return from_candid_opt_n6(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getBankConnection(arg0);
            return from_candid_opt_n6(this._uploadFile, this._downloadFile, result);
        }
    }
    async getBankConnections(): Promise<Array<BankConnection>> {
        if (this.processError) {
            try {
                const result = await this.actor.getBankConnections();
                return from_candid_vec_n12(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getBankConnections();
            return from_candid_vec_n12(this._uploadFile, this._downloadFile, result);
        }
    }
    async getBudget(arg0: BudgetId): Promise<Budget | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getBudget(arg0);
                return from_candid_opt_n13(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getBudget(arg0);
            return from_candid_opt_n13(this._uploadFile, this._downloadFile, result);
        }
    }
    async getBudgetSummary(arg0: bigint): Promise<BudgetSummary> {
        if (this.processError) {
            try {
                const result = await this.actor.getBudgetSummary(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getBudgetSummary(arg0);
            return result;
        }
    }
    async getBudgets(): Promise<Array<Budget>> {
        if (this.processError) {
            try {
                const result = await this.actor.getBudgets();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getBudgets();
            return result;
        }
    }
    async getCallerUserProfile(): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserProfile();
                return from_candid_opt_n14(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserProfile();
            return from_candid_opt_n14(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCallerUserRole(): Promise<UserRole> {
        if (this.processError) {
            try {
                const result = await this.actor.getCallerUserRole();
                return from_candid_UserRole_n15(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCallerUserRole();
            return from_candid_UserRole_n15(this._uploadFile, this._downloadFile, result);
        }
    }
    async getCategories(): Promise<Array<Category>> {
        if (this.processError) {
            try {
                const result = await this.actor.getCategories();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getCategories();
            return result;
        }
    }
    async getReport(arg0: bigint): Promise<Report | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getReport(arg0);
                return from_candid_opt_n17(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getReport(arg0);
            return from_candid_opt_n17(this._uploadFile, this._downloadFile, result);
        }
    }
    async getReports(): Promise<Array<Report>> {
        if (this.processError) {
            try {
                const result = await this.actor.getReports();
                return from_candid_vec_n23(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getReports();
            return from_candid_vec_n23(this._uploadFile, this._downloadFile, result);
        }
    }
    async getTags(): Promise<Array<Tag>> {
        if (this.processError) {
            try {
                const result = await this.actor.getTags();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getTags();
            return result;
        }
    }
    async getTransactions(): Promise<Array<Transaction>> {
        if (this.processError) {
            try {
                const result = await this.actor.getTransactions();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getTransactions();
            return result;
        }
    }
    async getTransactionsByDateRange(arg0: bigint, arg1: bigint): Promise<Array<Transaction>> {
        if (this.processError) {
            try {
                const result = await this.actor.getTransactionsByDateRange(arg0, arg1);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getTransactionsByDateRange(arg0, arg1);
            return result;
        }
    }
    async getUserProfile(arg0: Principal): Promise<UserProfile | null> {
        if (this.processError) {
            try {
                const result = await this.actor.getUserProfile(arg0);
                return from_candid_opt_n14(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.getUserProfile(arg0);
            return from_candid_opt_n14(this._uploadFile, this._downloadFile, result);
        }
    }
    async isCallerAdmin(): Promise<boolean> {
        if (this.processError) {
            try {
                const result = await this.actor.isCallerAdmin();
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.isCallerAdmin();
            return result;
        }
    }
    async listReports(): Promise<Array<Report>> {
        if (this.processError) {
            try {
                const result = await this.actor.listReports();
                return from_candid_vec_n23(this._uploadFile, this._downloadFile, result);
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.listReports();
            return from_candid_vec_n23(this._uploadFile, this._downloadFile, result);
        }
    }
    async saveCallerUserProfile(arg0: UserProfile): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.saveCallerUserProfile(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.saveCallerUserProfile(arg0);
            return result;
        }
    }
    async syncBankConnection(arg0: BankConnectionId): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.syncBankConnection(arg0);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.syncBankConnection(arg0);
            return result;
        }
    }
    async updateBankConnectionSyncStatus(arg0: BankConnectionId, arg1: BankConnectionStatus): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateBankConnectionSyncStatus(arg0, to_candid_BankConnectionStatus_n24(this._uploadFile, this._downloadFile, arg1));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateBankConnectionSyncStatus(arg0, to_candid_BankConnectionStatus_n24(this._uploadFile, this._downloadFile, arg1));
            return result;
        }
    }
    async updateBudget(arg0: BudgetId, arg1: bigint, arg2: Array<BudgetCategoryLimit>, arg3: number): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateBudget(arg0, arg1, arg2, arg3);
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateBudget(arg0, arg1, arg2, arg3);
            return result;
        }
    }
    async updateReport(arg0: bigint, arg1: ReportType, arg2: bigint, arg3: bigint, arg4: string | null): Promise<void> {
        if (this.processError) {
            try {
                const result = await this.actor.updateReport(arg0, to_candid_ReportType_n3(this._uploadFile, this._downloadFile, arg1), arg2, arg3, to_candid_opt_n5(this._uploadFile, this._downloadFile, arg4));
                return result;
            } catch (e) {
                this.processError(e);
                throw new Error("unreachable");
            }
        } else {
            const result = await this.actor.updateReport(arg0, to_candid_ReportType_n3(this._uploadFile, this._downloadFile, arg1), arg2, arg3, to_candid_opt_n5(this._uploadFile, this._downloadFile, arg4));
            return result;
        }
    }
}
function from_candid_BankConnectionStatus_n9(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _BankConnectionStatus): BankConnectionStatus {
    return from_candid_variant_n10(_uploadFile, _downloadFile, value);
}
function from_candid_BankConnection_n7(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _BankConnection): BankConnection {
    return from_candid_record_n8(_uploadFile, _downloadFile, value);
}
function from_candid_ReportType_n21(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _ReportType): ReportType {
    return from_candid_variant_n22(_uploadFile, _downloadFile, value);
}
function from_candid_Report_n18(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _Report): Report {
    return from_candid_record_n19(_uploadFile, _downloadFile, value);
}
function from_candid_UserRole_n15(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: _UserRole): UserRole {
    return from_candid_variant_n16(_uploadFile, _downloadFile, value);
}
function from_candid_opt_n11(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [bigint]): bigint | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n13(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_Budget]): Budget | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n14(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_UserProfile]): UserProfile | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n17(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_Report]): Report | null {
    return value.length === 0 ? null : from_candid_Report_n18(_uploadFile, _downloadFile, value[0]);
}
function from_candid_opt_n20(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [string]): string | null {
    return value.length === 0 ? null : value[0];
}
function from_candid_opt_n6(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: [] | [_BankConnection]): BankConnection | null {
    return value.length === 0 ? null : from_candid_BankConnection_n7(_uploadFile, _downloadFile, value[0]);
}
function from_candid_record_n19(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    id: bigint;
    filters: [] | [string];
    endDate: bigint;
    name: string;
    createdAt: bigint;
    reportType: _ReportType;
    updatedAt: bigint;
    startDate: bigint;
}): {
    id: bigint;
    filters?: string;
    endDate: bigint;
    name: string;
    createdAt: bigint;
    reportType: ReportType;
    updatedAt: bigint;
    startDate: bigint;
} {
    return {
        id: value.id,
        filters: record_opt_to_undefined(from_candid_opt_n20(_uploadFile, _downloadFile, value.filters)),
        endDate: value.endDate,
        name: value.name,
        createdAt: value.createdAt,
        reportType: from_candid_ReportType_n21(_uploadFile, _downloadFile, value.reportType),
        updatedAt: value.updatedAt,
        startDate: value.startDate
    };
}
function from_candid_record_n8(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    id: _BankConnectionId;
    status: _BankConnectionStatus;
    name: string;
    connectionType: string;
    nextSyncTimestamp: [] | [bigint];
    createdTimestamp: bigint;
    lastSync: [] | [bigint];
    retryAttempts: bigint;
}): {
    id: BankConnectionId;
    status: BankConnectionStatus;
    name: string;
    connectionType: string;
    nextSyncTimestamp?: bigint;
    createdTimestamp: bigint;
    lastSync?: bigint;
    retryAttempts: bigint;
} {
    return {
        id: value.id,
        status: from_candid_BankConnectionStatus_n9(_uploadFile, _downloadFile, value.status),
        name: value.name,
        connectionType: value.connectionType,
        nextSyncTimestamp: record_opt_to_undefined(from_candid_opt_n11(_uploadFile, _downloadFile, value.nextSyncTimestamp)),
        createdTimestamp: value.createdTimestamp,
        lastSync: record_opt_to_undefined(from_candid_opt_n11(_uploadFile, _downloadFile, value.lastSync)),
        retryAttempts: value.retryAttempts
    };
}
function from_candid_variant_n10(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    syncError: {
        error: string;
        timestamp: bigint;
    };
} | {
    idle: null;
} | {
    lastSynced: {
        timestamp: bigint;
    };
} | {
    inProgress: null;
}): {
    __kind__: "syncError";
    syncError: {
        error: string;
        timestamp: bigint;
    };
} | {
    __kind__: "idle";
    idle: null;
} | {
    __kind__: "lastSynced";
    lastSynced: {
        timestamp: bigint;
    };
} | {
    __kind__: "inProgress";
    inProgress: null;
} {
    return "syncError" in value ? {
        __kind__: "syncError",
        syncError: value.syncError
    } : "idle" in value ? {
        __kind__: "idle",
        idle: value.idle
    } : "lastSynced" in value ? {
        __kind__: "lastSynced",
        lastSynced: value.lastSynced
    } : "inProgress" in value ? {
        __kind__: "inProgress",
        inProgress: value.inProgress
    } : value;
}
function from_candid_variant_n16(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
}): UserRole {
    return "admin" in value ? UserRole.admin : "user" in value ? UserRole.user : "guest" in value ? UserRole.guest : value;
}
function from_candid_variant_n22(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    categoryBreakdown: null;
} | {
    incomeVsExpenses: null;
}): ReportType {
    return "categoryBreakdown" in value ? ReportType.categoryBreakdown : "incomeVsExpenses" in value ? ReportType.incomeVsExpenses : value;
}
function from_candid_vec_n12(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_BankConnection>): Array<BankConnection> {
    return value.map((x)=>from_candid_BankConnection_n7(_uploadFile, _downloadFile, x));
}
function from_candid_vec_n23(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: Array<_Report>): Array<Report> {
    return value.map((x)=>from_candid_Report_n18(_uploadFile, _downloadFile, x));
}
function to_candid_BankConnectionStatus_n24(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: BankConnectionStatus): _BankConnectionStatus {
    return to_candid_variant_n25(_uploadFile, _downloadFile, value);
}
function to_candid_ReportType_n3(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: ReportType): _ReportType {
    return to_candid_variant_n4(_uploadFile, _downloadFile, value);
}
function to_candid_UserRole_n1(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): _UserRole {
    return to_candid_variant_n2(_uploadFile, _downloadFile, value);
}
function to_candid_opt_n5(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: string | null): [] | [string] {
    return value === null ? candid_none() : candid_some(value);
}
function to_candid_variant_n2(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: UserRole): {
    admin: null;
} | {
    user: null;
} | {
    guest: null;
} {
    return value == UserRole.admin ? {
        admin: null
    } : value == UserRole.user ? {
        user: null
    } : value == UserRole.guest ? {
        guest: null
    } : value;
}
function to_candid_variant_n25(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: {
    __kind__: "syncError";
    syncError: {
        error: string;
        timestamp: bigint;
    };
} | {
    __kind__: "idle";
    idle: null;
} | {
    __kind__: "lastSynced";
    lastSynced: {
        timestamp: bigint;
    };
} | {
    __kind__: "inProgress";
    inProgress: null;
}): {
    syncError: {
        error: string;
        timestamp: bigint;
    };
} | {
    idle: null;
} | {
    lastSynced: {
        timestamp: bigint;
    };
} | {
    inProgress: null;
} {
    return value.__kind__ === "syncError" ? {
        syncError: value.syncError
    } : value.__kind__ === "idle" ? {
        idle: value.idle
    } : value.__kind__ === "lastSynced" ? {
        lastSynced: value.lastSynced
    } : value.__kind__ === "inProgress" ? {
        inProgress: value.inProgress
    } : value;
}
function to_candid_variant_n4(_uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, value: ReportType): {
    categoryBreakdown: null;
} | {
    incomeVsExpenses: null;
} {
    return value == ReportType.categoryBreakdown ? {
        categoryBreakdown: null
    } : value == ReportType.incomeVsExpenses ? {
        incomeVsExpenses: null
    } : value;
}
export interface CreateActorOptions {
    agent?: Agent;
    agentOptions?: HttpAgentOptions;
    actorOptions?: ActorConfig;
    processError?: (error: unknown) => never;
}
export function createActor(canisterId: string, _uploadFile: (file: ExternalBlob) => Promise<Uint8Array>, _downloadFile: (file: Uint8Array) => Promise<ExternalBlob>, options: CreateActorOptions = {}): Backend {
    const agent = options.agent || HttpAgent.createSync({
        ...options.agentOptions
    });
    if (options.agent && options.agentOptions) {
        console.warn("Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.");
    }
    const actor = Actor.createActor<_SERVICE>(idlFactory, {
        agent,
        canisterId: canisterId,
        ...options.actorOptions
    });
    return new Backend(actor, _uploadFile, _downloadFile, options.processError);
}
